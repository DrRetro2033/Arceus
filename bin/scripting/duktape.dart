import 'dart:ffi';
import 'dart:io' show Platform;
import 'package:ffi/ffi.dart' as ffi;
import 'package:talker/talker.dart';
import '../extensions.dart';

import 'duktape_bindings_generated.dart';
import '../arceus.dart';

DynamicLibrary _getDylib(String path) {
  if (Platform.isMacOS) {
    throw Exception("MacOS is not supported yet.");
  } else if (Platform.isLinux) {
    return DynamicLibrary.open("$path/duktape.so");
  } else if (Platform.isWindows) {
    return DynamicLibrary.open("$path/duktape.dll");
  }
  throw Exception("Unsupported platform.");
}

/// # `enum` DuktapeType
/// ## The type of a value in the Duktape instance.
/// TODO: See if this can be replaced with ffigen interface or something.
enum DuktapeType {
  string,
  int,
  double,
  bool,
}

/// # `class` Duktape
/// ## The main class for the Duktape instance.
/// It takes a list of [DuktapeFunction] objects and adds them to the global scope of the Duktape instance, to act as an API.
mixin Duktape {
  /// # `static` Talker talker
  /// ## The logger for the Duktape instance.
  static Talker talker = Talker();

  /// # `late` DuktapeBindings bindings
  /// ## The bindings for the Duktape instance.
  /// Generated by ffigen.
  static late DuktapeBindings bindings;

  /// # `static` bool isInitialized
  /// ## A flag to check if Duktape has been initialized and can be used.
  static bool isInitialized = false;

  /// # `static` void init(String pathToLibraries)
  /// ## Initializes the Duktape instance.
  static init(String pathToLibraries) {
    bindings = DuktapeBindings(_getDylib(pathToLibraries));
    isInitialized = true;
  }

  /// # `void` _createAPI(List<DuktapeFunction> apiFunctions)
  /// ## Creates the API for the Duktape instance.
  /// It takes a list of [DuktapeFunction] objects and adds them to the global scope of the Duktape instance.
  void createAPI(Pointer<duk_hthread> ctx, List<DuktapeFunction> apiFunctions) {
    for (DuktapeFunction func in apiFunctions) {
      bindings.duk_push_c_function(
          ctx,
          NativeCallable<Int Function(Pointer<duk_hthread> ctx)>.isolateLocal(
                  func.call,
                  exceptionalReturn: 0)
              .nativeFunction,
          func.nargs); // It just works.
      bindings.duk_put_global_string(
          // Push the function's name to the global scope, so it can be called with a name.
          ctx,
          func.name.toNativeUtf8().cast<Char>());
    }
  }

  /// # `String` eval(String code)
  /// ## Evaluates a string of code in the Duktape instance.
  /// It returns the result of the code as a string.
  String eval(Pointer<duk_hthread> ctx, String code) {
    final evalResult = bindings.duk_eval_raw(
        ctx,
        code.toCharPointer(),
        0,
        0 |
            DUK_COMPILE_SAFE |
            DUK_COMPILE_NOFILENAME |
            DUK_COMPILE_NOSOURCE |
            DUK_COMPILE_STRLEN);
    if (evalResult != 0) {
      throw Exception("Error evaluating: ${retrieveTopOfStackAsString(ctx)}");
    }

    return retrieveTopOfStackAsString(ctx);
  }

  /// # `String` call(String functionName, Map<String, dynamic> params)
  /// ## Calls a function in the Duktape instance with the given name and parameters.
  /// It returns the result of the function as a string.
  dynamic call(
      Pointer<duk_hthread> ctx, String functionName, List<dynamic> params) {
    bindings.duk_get_global_string(
        ctx, functionName.toNativeUtf8().cast<Char>());
    for (dynamic param in params) {
      if (param is String) {
        bindings.duk_push_string(ctx, (param).toCharPointer());
      } else if (param is int) {
        bindings.duk_push_int(ctx, param);
      } else if (param is double) {
        bindings.duk_push_number(ctx, param);
      } else if (param is bool) {
        bindings.duk_push_boolean(ctx, param ? 1 : 0);
      }
    }
    final result = bindings.duk_pcall(ctx, params.length);
    if (result != 0) {
      throw Exception("Error calling: ${retrieveTopOfStackAsString(ctx)}");
    }
    return getReturnValue(ctx);
  }

  dynamic getReturnValue(Pointer<duk_hthread> ctx) {
    if (bindings.duk_is_object(ctx, -1) == 1) {
      Map<String, dynamic> obj = {};
      bindings.duk_enum(ctx, -1, DUK_ENUM_OWN_PROPERTIES_ONLY);
      while (bindings.duk_next(ctx, -1, 1) == 1) {
        obj[_getValueAt(ctx, -2)] = _getValueAt(ctx, -1);
        bindings.duk_pop_2(ctx);
      }
      bindings.duk_pop(ctx);
      return obj;
    }
  }

  dynamic _getValueAt(Pointer<duk_hthread> ctx, int idx) {
    if (bindings.duk_is_string(ctx, idx) == 1) {
      return bindings.duk_get_string(ctx, idx).toDartString();
    } else if (bindings.duk_is_number(ctx, idx) == 1) {
      double number = bindings.duk_get_number(ctx, idx);
      if (number.round().toDouble() != number) return number;
      return number.round();
    } else if (bindings.duk_is_boolean(ctx, idx) == 1) {
      return bindings.duk_get_boolean(ctx, idx) == 1 ? true : false;
    }
  }

  /// # `String` _retrieveTopOfStackAsString()
  /// ## Retrieves the top of the stack as a string.
  /// It returns the result of the function as a string.
  String retrieveTopOfStackAsString(Pointer<duk_hthread> ctx) {
    Pointer<Size> outLengthPtr = ffi.calloc<Size>();
    final errorStrPtr = bindings.duk_safe_to_lstring(ctx, -1, outLengthPtr);
    final returnVal =
        errorStrPtr.cast<ffi.Utf8>().toDartString(length: outLengthPtr.value);
    ffi.calloc.free(outLengthPtr);
    return returnVal;
  }

  Map<String, dynamic> retrieveTopOfStackAsMap() {
    return {};
  }

  /// # `void` dispose()
  /// ## Disposes the Duktape instance.
  void dispose(Pointer<duk_hthread> ctx) {
    bindings.duk_destroy_heap(ctx);
    ctx = nullptr;
  }
}

/// # `void` DuktapeFunction(String name, Map<String, DuktapeType> arguments, dynamic Function(Pointer<duk_hthread> ctx, Map<String, dynamic> params) call)
/// ## A function that can be called from inside a Duktape instance.
/// It takes a name, a map of arguments, and a function to call.
class DuktapeFunction {
  final String name;

  final Map<String, DuktapeType> arguments;

  final dynamic Function(Pointer<duk_hthread> ctx, Map<String, dynamic> params)
      _call;

  DuktapeFunction(
    this.name,
    this.arguments,
    this._call,
  );

  int get nargs => arguments.entries.length;

  Map<String, dynamic> _getParams(ctx) {
    Map<String, dynamic> params = {};
    int idx = 0;
    for (String key in arguments.keys) {
      switch (arguments[key]) {
        case DuktapeType.string:
          params[key] = Duktape.bindings.duk_get_string(ctx, idx);
          break;
        case DuktapeType.int:
          params[key] = Duktape.bindings.duk_get_int(ctx, idx);
          break;
        case DuktapeType.double:
          params[key] = Duktape.bindings.duk_get_number(ctx, idx);
          break;
        case DuktapeType.bool:
          params[key] =
              Duktape.bindings.duk_get_boolean(ctx, idx) == 1 ? true : false;
          break;
        default:
          break;
      }
      idx++;
    }
    return params;
  }

  void _returnDuktapeValue(Pointer<duk_hthread> ctx, dynamic value) {
    if (value is String) {
      Duktape.bindings.duk_push_string(ctx, value.toNativeUtf8().cast<Char>());
    } else if (value is int) {
      Duktape.bindings.duk_push_int(ctx, value);
    } else if (value is double) {
      Duktape.bindings.duk_push_number(ctx, value);
    } else if (value is bool) {
      Duktape.bindings.duk_push_boolean(ctx, value ? 1 : 0);
    }
  }

  int call(Pointer<duk_hthread> ctx) {
    try {
      final result = _call(ctx, _getParams(ctx));
      if (result != null) {
        _returnDuktapeValue(ctx, result);
      }
    } catch (e) {
      print(e);
      return e.hashCode;
    }
    return 1;
  }
}
