import 'dart:ffi';
import 'dart:io' show Platform;
import 'package:arceus/arceus.dart';
import 'package:ffi/ffi.dart' as ffi;
import 'package:ffi/ffi.dart';
import 'package:talker/talker.dart';
import '../extensions.dart';

import 'squirrel_bindings_generated.dart';

DynamicLibrary _getDylib() {
  if (Arceus.isDev) {
    return DynamicLibrary.open(
        "${const String.fromEnvironment('LIBRARY_PATH', defaultValue: 'C://Repos/arceus/')}/squirrel.dll");
  }
  if (Platform.isMacOS) {
    throw Exception("MacOS is not supported yet.");
  } else if (Platform.isLinux) {
    return DynamicLibrary.open("${Arceus.getLibraryPath()}/lib/squirrel.so");
  } else if (Platform.isWindows) {
    return DynamicLibrary.open("${Arceus.getLibraryPath()}/squirrel.dll");
  }
  throw Exception("Unsupported platform.");
}

Pointer<NativeFunction<Void Function(Pointer<SQVM>, Pointer<Char>)>>
    printSquirl = Pointer.fromFunction(_printSquirl);
void _printSquirl(Pointer<SQVM> vm, Pointer<Char> s) {
  print(s.toDartString());
  return;
}

class Squirrel {
  /// # `static` Talker talker
  /// ## The logger for the Squirrel instance.
  static Talker talker = Talker();

  /// # `late` SquirrelBindings bindings
  /// ## The bindings for the Squirrel instance.
  /// Generated by ffigen.
  static late SquirrelBindings bindings;

  /// # `static` bool isInitialized
  /// ## A flag to check if Squirrel has been initialized and can be used.
  static bool isInitialized = false;

  /// # `static` void init(String pathToLibraries)
  /// ## Initializes the Squirrel libraries.
  static init(String pathToLibraries) {
    bindings = SquirrelBindings(_getDylib());
    isInitialized = true;
  }

  /// # `static` Pointer<SQVM> start(String filename, String code)
  /// ## Compiles code and starts the Squirrel instance.
  static Pointer<SQVM> run(String code) {
    if (!isInitialized) {
      throw Exception("Squirrel is not initialized.");
    }
    final vm = bindings.sq_open(1024);
    bindings.sq_setprintfunc(vm, printSquirl, printSquirl);
    final pointer = code.toCharPointer();
    successful(
        vm,
        bindings.sq_compilebuffer(vm, pointer, code.toNativeUtf8().length,
            "run.nut".toCharPointer(), SQTrue));
    malloc.free(pointer);
    bindings.sq_pushroottable(vm);
    successful(vm, bindings.sq_call(vm, 1, SQFalse, SQTrue));
    bindings.sq_collectgarbage(vm);
    bindings.sq_pop(vm, 1);
    return vm;
  }

  /// # `static` void dispose(Pointer<SQVM> vm)
  /// ## Closes the Squirrel instance.
  static void dispose(Pointer<SQVM> vm) {
    bindings.sq_close(vm);
  }

  /// # `void` _createAPI(List<SquirrelFunction> apiFunctions)
  /// ## Creates the API for the Squirrel instance.
  /// It takes a list of [SquirrelFunction] objects and adds them to the global scope of the Squirrel instance.
  static void createAPI(Pointer<SQVM> vm, List<SquirrelFunction> apiFunctions) {
    for (SquirrelFunction func in apiFunctions) {
      bindings.sq_pushroottable(vm);
      bindings.sq_pushstring(
          vm, func.name.toCharPointer(), func.name.toNativeUtf8().length);
      bindings.sq_newclosure(
          vm,
          NativeCallable<LongLong Function(Pointer<SQVM> ctx)>.isolateLocal(
                  func.call,
                  exceptionalReturn: 0)
              .nativeFunction,
          0);
      bindings.sq_newslot(vm, -3, SQFalse);
      bindings.sq_pop(vm, 1);
    }
  }

  /// # `static` void successful(Pointer<SQVM> vm, int result)
  /// ## Throws an exception if the result is not 0.
  /// It will also print the stack of the Squirrel instance.
  static void successful(Pointer<SQVM> vm, int result) {
    if (result != 0) {
      bindings.sq_getlasterror(vm);
      final error = getValueFromStack(vm);
      throw Exception("$error \n ${getStack(vm)}");
    }
  }

  /// # `static` void getStack(Pointer<SQVM> vm)
  /// ## Gets the stack of the Squirrel instance.
  static List<String> getStack(Pointer<SQVM> vm) {
    List<String> stack = [];
    int i = bindings.sq_gettop(vm);
    while (i > 0) {
      bindings.sq_tostring(vm, i);
      final p = ffi.calloc<Pointer<Char>>();
      bindings.sq_getstring(vm, -1, p);
      stack.add(p.value.toDartString());
      ffi.calloc.free(p);
      bindings.sq_pop(vm, 1);
      i--;
    }
    return stack;
  }

  static String getStackForPrint(Pointer<SQVM> vm) {
    final stack = getStack(vm);
    return stack.join("\n");
  }

  /// # `static` dynamic call(String functionName, [List<dynamic> args = const []])
  /// ## Calls a function in the Squirrel instance.
  /// Will return the return value of the function, if any.
  static dynamic call(Pointer<SQVM> vm, String functionName,
      {List<dynamic> args = const []}) {
    bindings.sq_pushroottable(vm);
    bindings.sq_pushstring(
        vm, functionName.toCharPointer(), functionName.length);
    bindings.sq_get(vm, -2);
    bindings.sq_pushroottable(vm);
    for (dynamic arg in args) {
      pushToStack(vm, arg);
    }
    successful(
        vm,
        bindings.sq_call(vm, args.length + 1, SQTrue,
            SQTrue)); // Calls and checks if the call was successful.
    final returnValue = getValueFromStack(vm); // Returns the return value.
    bindings.sq_pop(vm, 2); // Pops the function and the root table.
    // malloc.free(vm);
    return returnValue;
  }

  static dynamic getValueFromStack(HSQUIRRELVM vm,
      {tagSQObjectType? expectedType,
      dynamic defaultValue,
      int index = -1,
      bool noPop = false}) {
    final result = bindings.sq_gettype(vm, index);
    dynamic value;
    if (expectedType != null && result.index != expectedType.index) {
      if (defaultValue != null) {
        return defaultValue;
      }
      throw Exception(
          "Expected type $expectedType but got $result. Squirrel Stack: \n${getStackForPrint(vm)}");
    } else {
      // print("Type: $result");
    }

    if (result == tagSQObjectType.OT_STRING) {
      final p = ffi.calloc<Pointer<Char>>();
      try {
        bindings.sq_getstring(
            vm, index, p); // pass along the pointer to get the value.
        value = p.value.toDartString();
      } finally {
        ffi.calloc.free(p); // free memory
      }
    } else if (result == tagSQObjectType.OT_INTEGER) {
      final p = ffi.calloc<LongLong>();
      try {
        bindings.sq_getinteger(vm, index, p);
        value = p.value;
      } finally {
        ffi.calloc.free(p);
      }
    } else if (result == tagSQObjectType.OT_FLOAT) {
      final p = ffi.calloc<Float>();
      try {
        bindings.sq_getfloat(vm, index, p);
        value = p.value;
      } finally {
        ffi.calloc.free(p);
      }
    } else if (result == tagSQObjectType.OT_BOOL) {
      final p = ffi.calloc<UnsignedLongLong>();
      try {
        bindings.sq_getbool(vm, index, p);
        value = p.value == 1 ? true : false;
      } finally {
        ffi.calloc.free(p);
      }
    } else if (result == tagSQObjectType.OT_ARRAY) {
      bindings.sq_pushnull(vm);
      value = [];
      while (bindings.sq_next(vm, -2) == 1) {
        (value as List).add(getValueFromStack(vm, index: -1, noPop: true));
        bindings.sq_pop(vm, 2);
      }
    } else if (result == tagSQObjectType.OT_TABLE) {
      bindings.sq_pushnull(vm);
      value = {};
      while (bindings.sq_next(vm, -2) == 0) {
        // print("Stack \n${getStackForPrint(vm)}");
        (value as Map).putIfAbsent(
            getValueFromStack(vm, index: -2, noPop: true),
            () => getValueFromStack(vm, index: -1, noPop: true));
        bindings.sq_pop(vm, 2);
      }
      if (bindings.sq_gettype(vm, -1) != tagSQObjectType.OT_TABLE) {
        bindings.sq_pop(vm, 1);
      }
    } else if (result == tagSQObjectType.OT_NULL) {
      value = null;
    } else {
      print("Unknown type: $result");
      value = null;
    }

    if (!noPop) {
      bindings.sq_pop(vm, 1);
    }
    return value;
  }

  static void pushToStack(HSQUIRRELVM vm, dynamic value) {
    if (value is String) {
      bindings.sq_pushstring(vm, value.toCharPointer(), value.length);
    } else if (value is int) {
      bindings.sq_pushinteger(vm, value);
    } else if (value is double) {
      bindings.sq_pushfloat(vm, value);
    } else if (value is bool) {
      bindings.sq_pushbool(vm, value ? 1 : 0);
    } else if (value is List<dynamic>) {
      bindings.sq_newarray(vm, 0);
      for (int i = 0; i < value.length; i++) {
        pushToStack(vm, value[i]);
        if (bindings.sq_arrayappend(vm, -2) == SQ_ERROR) {
          bindings.sq_pop(vm, 1);
          break;
        }
      }
    } else {
      bindings.sq_pushnull(vm);
    }
  }
}

/// # `void` DukapeFunction(String name, Map<String, DuktapeType> arguments, dynamic Function(Pointer<duk_hthread> ctx, Map<String, dynamic> params) call)
/// ## A function that can be called from inside a Duktape instance.
/// It takes a name, a map of arguments, and a function to call.t
class SquirrelFunction {
  final String name;

  /// # `Map<String, dynamic>`
  /// ## The arguments of the function.
  /// Only use either tagSQObjectType, or records with the format of (tagSQObjectType, defaultValue) for optional arguments.
  /// Example: (tagSQObjectType.OT_INTEGER, 0)
  /// Optional arguments must be at the end of the list, to avoid skipping required arguments.
  final Map<String, dynamic> arguments;

  final dynamic Function(Pointer<SQVM> vm, Map<String, dynamic> params) _call;

  SquirrelFunction(
    this.name,
    this.arguments,
    this._call,
  );

  int get nargs => arguments.entries.length;

  Map<String, dynamic> _getParams(Pointer<SQVM> vm) {
    Map<String, dynamic> params = {};
    // print(arguments.keys.toList().reversed);
    for (String key in arguments.keys.toList().reversed) {
      switch (arguments[key]) {
        case tagSQObjectType.OT_STRING:
          params[key] = Squirrel.getValueFromStack(vm,
              expectedType: tagSQObjectType.OT_STRING);
          break;
        case tagSQObjectType.OT_INTEGER:
          params[key] = Squirrel.getValueFromStack(vm,
              expectedType: tagSQObjectType.OT_INTEGER);
          break;
        case tagSQObjectType.OT_FLOAT:
          params[key] = Squirrel.getValueFromStack(vm,
              expectedType: tagSQObjectType.OT_FLOAT);
          break;
        case tagSQObjectType.OT_BOOL:
          params[key] = Squirrel.getValueFromStack(vm,
              expectedType: tagSQObjectType.OT_BOOL);
          break;
        default:
          if (arguments[key] is Map) {
            params[key] = arguments[key].cast<dynamic, dynamic>();
            Map<dynamic, dynamic> table = Squirrel.getValueFromStack(
              vm,
              expectedType: tagSQObjectType.OT_TABLE,
              defaultValue: arguments[key],
            );
            params[key].addAll(table);
          } else if (arguments[key] is (tagSQObjectType, dynamic)) {
            try {
              params[key] = Squirrel.getValueFromStack(vm,
                  expectedType: arguments[key].$1,
                  defaultValue: arguments[key].$2);
            } catch (e) {
              throw ('Tried to use given record ${arguments[key]} as argument. Expected record must be (tagSQObjectType, dynamic)');
            }
          }
      }
    }
    return params;
  }

  /// # `void` _returnValue(Pointer<SQVM> vm, dynamic value)
  /// ## Pushes the return value to the stack.
  /// It will also print the stack of the Squirrel instance.
  void _returnValue(Pointer<SQVM> vm, dynamic value) {
    Squirrel.pushToStack(vm, value);
  }

  /// # `int` call(Pointer<SQVM> vm)
  /// ## Calls the function given Dart function and return its result to Squirrel.
  int call(Pointer<SQVM> vm) {
    try {
      final result = _call(vm, _getParams(vm));
      if (result != null) {
        _returnValue(vm, result);
      }
    } catch (e) {
      print(e);
      return e.hashCode;
    }
    return 1;
  }
}
